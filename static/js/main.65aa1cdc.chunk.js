(this["webpackJsonpsorting-algorithms"]=this["webpackJsonpsorting-algorithms"]||[]).push([[0],[,,,,,,,,function(t,e,n){t.exports=n(16)},,,,,function(t,e,n){},function(t,e,n){},function(t,e,n){},function(t,e,n){"use strict";n.r(e);var r=n(0),a=n.n(r),i=n(3),o=n.n(i),s=(n(13),n(1)),l=n(4),h=n(5),u=n(7),c=n(6);n(14);function m(t){var e=[],n=t.slice();return function t(e,n,r,a,i){if(a===i)return;var o=Math.floor((a+i)/2);t(n,e,r,a,o),t(n,e,r,o+1,i),function(t,e,n,r,a,i){var o=r,s=a+1,l=r;for(;o<=a&&s<=i;)n.push(["comparison",o,s]),n.push(["finish_compare",o,s]),e[o]<=e[s]?(n.push(["swap",o,l]),n.push(["swap2",e[o],t[l]]),t[l++]=e[o++]):(n.push(["swap",s,l]),n.push(["swap2",e[s],t[l]]),t[l++]=e[s++]);for(;o<=a;)n.push(["swap",o,l]),n.push(["swap2",e[o],t[l]]),t[l++]=e[o++];for(;s<=i;)n.push(["swap",s,l]),n.push(["swap2",e[s],t[l]]),t[l++]=e[s++]}(e,n,r,a,o,i)}(t,n,e,0,t.length-1),e}function d(t,e,n,r){if(e<n){var a=function(t,e,n,r){var a=e-1,i=t[n];r.push(["pivot_highlight",n,n]);for(var o=e;o<n;o+=1)if(t[o]<i){a+=1,r.push(["swap_compared",a,o]),r.push(["swap_elements",t[a],t[o]]);var s=t[a];t[a]=t[o],t[o]=s}r.push(["pivot_unhighlight",n,n]),r.push(["swap_compared",n,a+1]),r.push(["swap_elements",t[n],t[a+1]]);var l=t[n];return t[n]=t[a+1],t[a+1]=l,a+1}(t,e,n,r);d(t,e,a-1,r),d(t,a+1,n,r)}}function g(t){var e=[];return function(t,e){for(var n=e.length,r=Math.floor(n/2-1);r>=0;r--)p(t,e,n,r);for(var a=n-1;a>0;a--){t.push(["swap",a,0]),t.push(["heights",e[a],e[0]]);var i=e[a];e[a]=e[0],e[0]=i,p(t,e,a,0)}}(e,t),e}function p(t,e,n,r){var a=r,i=2*r+1,o=2*r+2;if(i<n&&e[a]<e[i]&&(a=i),o<n&&e[a]<e[o]&&(a=o),a!==r){t.push(["swap",r,a]),t.push(["heights",e[r],e[a]]);var s=e[a];e[a]=e[r],e[r]=s,p(t,e,n,a)}}var f=[],y=function(t){Object(u.a)(n,t);var e=Object(c.a)(n);function n(t){var r;return Object(l.a)(this,n),(r=e.call(this,t)).state={array:[]},r}return Object(h.a)(n,[{key:"componentDidMount",value:function(){this.newArray()}},{key:"quickSort",value:function(){this.disableButtons(),document.getElementById("algorithm_info").innerHTML='<h2> Algorithm: Quicksort</h2> \n            <p> Quicksort relies primarily on the idea of the "partition algorithm" - the algorithm\n                selects a pivot element within the array and places it in its correct position\n                in the sorted array. In the process, the algorithm ensures that every element to the\n                left of the pivot is smaller than it is, and every element to the right of the\n                pivot is larger than it is. By repeating this process on each pair of left and right\n                partitions, we successfully sort the entire array. </p>\n        <h2> Time Complexity </h2>\n        <div id="complexity_table">\n            <table>\n                <tr>\n                    <td> Worst Case </td>\n                    <td> O(n<sup>2</sup>) </td>\n                </tr>\n                <tr>\n                    <td> Average Case </td>\n                    <td> O(nlog(n)) </td>\n                </tr>\n                <tr>\n                    <td> Best Case </td>\n                    <td> O(nlog(n)) </td>\n                </tr>\n            </table>\n        </div>\n        <p> Note: Even though Quicksort runs in O(n<sup>2</sup>) time in the worst case,\n            it almost never runs this slow due to the many ways a pivot can be selected\n            (first element, last element, random element, etc). Because it almost never runs\n            in the worst case time it is quite popular, and the fact that it often runs much \n            faster than alternative algorithms explains its namesake! </p>',f=[];for(var t=function(t){var e=[];return d(t,0,t.length-1,e),e}(this.state.array),e=0,n=document.getElementsByClassName("array_element");e<t.length;){var r=Object(s.a)(t[e],3),a=r[0],i=r[1],o=r[2];if("pivot_highlight"===a)this.singleElementHighlight(n,i,e,"red"),e++;else if("pivot_unhighlight"===a)this.singleElementUnHighlight(n,i,e),e++;else if("swap_compared"===a){var l=Object(s.a)(t[e+1],3),h=l[1],u=l[2];this.elementSwap(n,i,h,o,u,e),e+=2}}this.completeSorting(e,n)}},{key:"mergeSort",value:function(){this.disableButtons(),document.getElementById("algorithm_info").innerHTML='<h2> Algorithm: Merge Sort</h2> \n            <p>Merge Sort works by recursively splitting the array in half until we reach\n                a single element, at which point we begin comparing element by element.\n                This allows each portion of the array to be sorted in a row, which explains\n                the "chunks" that you can see while the algorithm runs. </p>\n        <h2> Time Complexity </h2>\n        <div id="complexity_table">\n            <table>\n                <tr>\n                    <td> Worst Case </td>\n                    <td> O(nlog(n)) </td>\n                </tr>\n                <tr>\n                    <td> Average Case </td>\n                    <td> O(nlog(n)) </td>\n                </tr>\n                <tr>\n                    <td> Best Case </td>\n                    <td> O(nlog(n)) </td>\n                </tr>\n            </table>\n        </div>\n        <p> Note: Merge Sort always runs in the same time - O(nlog(n)) - due to the fact that \n            it separates the array in half every time, no matter what. This makes it quite \n            effective for larger arrays/lists, as you can guarantee a fast run time. </p>',f=[];for(var t=m(this.state.array),e=0,n=document.getElementsByClassName("array_element");e<t.length;){var r=Object(s.a)(t[e],3),a=r[0],i=r[1],o=r[2];"comparison"===a?(this.singleElementHighlight(n,i,e,"blue"),this.singleElementHighlight(n,o,e,"blue"),this.singleElementUnHighlight(n,i,e+1,"blue"),this.singleElementUnHighlight(n,o,e+1,"blue")):"swap"===a&&function(){var r=n[i].style,a=n[o].style;f.push(setTimeout((function(){r.backgroundColor="blue",a.backgroundColor="blue"}),3*e));var l=Object(s.a)(t[e+1],2)[1];f.push(setTimeout((function(){a.height="".concat(2*l,"px"),r.backgroundColor="burlywood",a.backgroundColor="burlywood"}),3*(e+1)))}(),e+=2}this.completeSorting(e,n)}},{key:"insertionSort",value:function(){var t=this;this.disableButtons(),document.getElementById("algorithm_info").innerHTML='<h2> Algorithm: Insertion Sort</h2> \n            <p> Insertion Sort is one of the simpler sorting algorithms: it iterates across the full\n                array and sorts it one element at a time, guaranteeing that the first n+1 elements are\n                sorted on the "nth" iteration. Though usually inefficient, its advantages are in the fact\n                that it is not difficult to implement and that it requires no additional space to sort.</p>\n        <h2> Time Complexity </h2>\n        <div id="complexity_table">\n            <table>\n                <tr>\n                    <td> Worst Case </td>\n                    <td> O(n<sup>2</sup>) </td>\n                </tr>\n                <tr>\n                    <td> Average Case </td>\n                    <td> O(n<sup>2</sup>) </td>\n                </tr>\n                <tr>\n                    <td> Best Case </td>\n                    <td> O(n) </td>\n                </tr>\n            </table>\n        </div>\n        <p> Note: Insertion Sort is quite slow on large arrays, but its saving grace is that\n            it has O(n) runtime on sorted arrays. So, on very small arrays (<10 entries), Insertion\n            Sort can outperform almost every other Sorting Algorithm! In fact, some versions of Quick Sort\n            actually use Insertion Sort as array partitions approach this size!</p>',f=[];for(var e=function(t){var e=[];return function(t,e){for(var n=1;n<t.length;n++){for(var r=t[n],a=n-1;a>=0&&r<t[a];)e.push(["swap",a+1,a]),e.push(["swap2",t[a+1],t[a]]),t[a+1]=t[a],a-=1;e.push(["reassign",a+1,r]),t[a+1]=r}}(t,e),e}(this.state.array),n=0,r=document.getElementsByClassName("array_element"),a=function(){var a=Object(s.a)(e[n],3),i=a[0],o=a[1],l=a[2];if("swap"===i){var h=Object(s.a)(e[n+1],3),u=h[1],c=h[2];t.elementSwap(r,o,u,l,c,n),n+=2}else if("reassign"===i){var m=r[o].style;f.push(setTimeout((function(){m.height="".concat(2*l,"px")}),3*n)),n+=1}};n<e.length;)a();this.completeSorting(n,r)}},{key:"bubbleSort",value:function(){this.disableButtons(),document.getElementById("algorithm_info").innerHTML='<h2> Algorithm: Bubble Sort</h2> \n            <p> Bubble Sort is the most simple sorting algorithm, usually used more to teach\n                concepts than to effectively sort arrays. It works by comparing each pair of elements,\n                swapping if they are in the wrong order. This guarantees that the final n elements\n                will be sorted on the "nth" pass through the array, but can lead to extremely\n                slow sorting times.</p>\n        <h2> Time Complexity </h2>\n        <div id="complexity_table">\n            <table>\n                <tr>\n                    <td> Worst Case </td>\n                    <td> O(n<sup>2</sup>) </td>\n                </tr>\n                <tr>\n                    <td> Average Case </td>\n                    <td> O(n<sup>2</sup>) </td>\n                </tr>\n                <tr>\n                    <td> Best Case </td>\n                    <td> O(n) </td>\n                </tr>\n            </table>\n        </div>\n        <p> Note: Bubble Sort, similar to Insertion Sort, also runs in O(n) time when the \n            array is already sorted. As a result it can also be used on mostly sorted arrays, \n            but Insertion Sort is often preferred. </p>',f=[];for(var t=function(t){var e=[];return function(t,e){for(var n=e.length,r=0;r<n;r++){for(var a=!1,i=0;i<n-r-1;i++)if(e[i]>e[i+1]){t.push(["swap",i,i+1]),t.push(["heights",e[i],e[i+1]]);var o=e[i+1];e[i+1]=e[i],e[i]=o,a=!0}if(!a)break}}(e,t),e}(this.state.array),e=0,n=document.getElementsByClassName("array_element");e<t.length;){var r=Object(s.a)(t[e],3),a=r[0],i=r[1],o=r[2];if("swap"===a){var l=Object(s.a)(t[e+1],3),h=l[1],u=l[2];this.elementSwap(n,i,h,o,u,e),e+=2}}this.completeSorting(e,n)}},{key:"heapSort",value:function(){this.disableButtons(),document.getElementById("algorithm_info").innerHTML='<h2> Algorithm: Heapsort</h2> \n            <p> Heapsort sorts by first constructing a Max Heap data structure, and then afterwards\n                makes sure that the Heap invariant is preserved - this invariant being the idea that\n                if one node is a parent of another, the parent value is greater than or equal to\n                the child value. This causes the array to become sorted from back to front, as the \n                largest values are processed first (as parent nodes) followed by the smaller ones (children). </p>\n        <h2> Time Complexity </h2>\n        <div id="complexity_table">\n            <table>\n                <tr>\n                    <td> Worst Case </td>\n                    <td> O(nlog(n)) </td>\n                </tr>\n                <tr>\n                    <td> Average Case </td>\n                    <td> O(nlog(n)) </td>\n                </tr>\n                <tr>\n                    <td> Best Case </td>\n                    <td> O(nlog(n)) </td>\n                </tr>\n            </table>\n        </div>\n        <p> Note: Though Heapsort itself is not popular in comparison with strong alternatives\n            like Quick Sort or Merge Sort, it is quite useful because it produces a Heap, which\n            has lots of uses in Computer Science (including Djikstra\'s algorithm for path-finding).\n            Additionally, though Quick Sort is almost always faster, the fact that its worst case runtime\n            is O(n<sup>2</sup>) makes Heapsort a much better option when maximum time is a real concern. </p>',f=[];for(var t=g(this.state.array),e=0,n=document.getElementsByClassName("array_element");e<t.length;){var r=Object(s.a)(t[e],3),a=r[0],i=r[1],o=r[2];if("swap"===a){var l=Object(s.a)(t[e+1],3),h=l[1],u=l[2];this.elementSwap(n,i,h,o,u,e),e+=2}}this.completeSorting(e,n)}},{key:"selectionSort",value:function(){this.disableButtons(),document.getElementById("algorithm_info").innerHTML='<h2> Algorithm: Selection Sort</h2> \n            <p> Selection Sort sorts by dividing the array into two parts: on the "nth"\n                pass through the array, the first n items are sorted, and the remaining\n                subarray (everything to the right of entry n) are not. It works by\n                calculating the minimum remaining entry in the unsorted subarray and \n                moving it to the end of the sorted subarray, until the entire array is sorted.</p>\n        <h2> Time Complexity </h2>\n        <div id="complexity_table">\n            <table>\n                <tr>\n                    <td> Worst Case </td>\n                    <td> O(n<sup>2</sup>) </td>\n                </tr>\n                <tr>\n                    <td> Average Case </td>\n                    <td> O(n<sup>2</sup>) </td>\n                </tr>\n                <tr>\n                    <td> Best Case </td>\n                    <td> O(n<sup>2</sup>) </td>\n                </tr>\n            </table>\n        </div>\n        <p> Note: Selection Sort runs in O(n<sup>2</sup>) time no matter what. However, it \n            can be preferred in certain situations due to the fact that it makes n-1 swaps\n            in the worst case. This is paired with the fact that Selection Sort sorts in place \n            (no extra required). So, if memory is an issue, it is quite handy! </p>',f=[];for(var t=function(t){var e=[];return function(t,e){for(var n=0;n<t.length;n++){var r=n;e.push(["current_highlight",n,n]);for(var a=n+1;a<t.length;a++)e.push(["current_highlight",a,a]),t[r]>t[a]?(e.push(["current_unhighlight",r,r]),r=a,e.push(["current_highlight",a,a])):e.push(["current_unhighlight",a,a]);e.push(["current_unhighlight",r,r]),e.push(["swap",n,r]),e.push(["heights",t[n],t[r]]);var i=t[r];t[r]=t[n],t[n]=i}}(t,e),e}(this.state.array),e=0,n=document.getElementsByClassName("array_element");e<t.length;){var r=Object(s.a)(t[e],3),a=r[0],i=r[1],o=r[2];if("swap"===a){var l=Object(s.a)(t[e+1],3),h=l[1],u=l[2];this.elementSwap(n,i,h,o,u,e),e+=2}else"current_highlight"===a?(this.singleElementHighlight(n,i,e,"blue"),e++):"current_unhighlight"===a&&(this.singleElementUnHighlight(n,i,e),e++)}this.completeSorting(e,n)}},{key:"singleElementHighlight",value:function(t,e,n,r){var a=t[e].style;f.push(setTimeout((function(){a.backgroundColor=r}),3*n))}},{key:"singleElementUnHighlight",value:function(t,e,n){var r=t[e].style;f.push(setTimeout((function(){r.backgroundColor="burlywood"}),3*n))}},{key:"elementSwap",value:function(t,e,n,r,a,i){var o=t[e].style,s=t[r].style;f.push(setTimeout((function(){o.backgroundColor="blue",s.backgroundColor="blue"}),3*i)),f.push(setTimeout((function(){o.height="".concat(2*a,"px"),s.height="".concat(2*n,"px"),o.backgroundColor="burlywood",s.backgroundColor="burlywood"}),3*(i+1)))}},{key:"completeSorting",value:function(t,e){for(var n=this,r=0;r<e.length;r++)this.singleElementHighlight(e,r,t+r+1,"rgb(48, 150, 48)");for(var a=0;a<e.length;a++)this.singleElementUnHighlight(e,a,t+e.length+1);f.push(setTimeout((function(){n.enableButtons()}),3*(t+e.length+1)))}},{key:"render",value:function(){var t=this,e=this.state.array;return a.a.createElement(a.a.Fragment,null,a.a.createElement("div",{className:"buttons"},a.a.createElement("button",{id:"shuffle",onClick:function(){return t.newArray()}},"Shuffle Array"),a.a.createElement("button",{id:"quick",onClick:function(){return t.quickSort()}},"Quicksort"),a.a.createElement("button",{id:"merge",onClick:function(){return t.mergeSort()}},"Merge Sort"),a.a.createElement("button",{id:"insertion",onClick:function(){return t.insertionSort()}},"Insertion Sort"),a.a.createElement("button",{id:"bubble",onClick:function(){return t.bubbleSort()}},"Bubble Sort"),a.a.createElement("button",{id:"heap",onClick:function(){return t.heapSort()}},"Heapsort"),a.a.createElement("button",{id:"selection",onClick:function(){return t.selectionSort()}},"Selection Sort"),a.a.createElement("button",{id:"skip",onClick:function(){return t.skipAnimations()}}," ","Skip"," ")),a.a.createElement("div",{id:"array_area",style:{alignItems:"center"}},e.map((function(t,e){return a.a.createElement("div",{className:"array_element",key:e,style:{height:"".concat(2*t,"px")}})}))),a.a.createElement("h3",null," Toggle Array Orientation "),a.a.createElement("div",{className:"stylebuttons"},a.a.createElement("button",{onClick:function(){return t.arrayStyle("flex-start")}},"Upper (Icicles)"),a.a.createElement("button",{onClick:function(){return t.arrayStyle("center")}},"Middle (Signal)"),a.a.createElement("button",{onClick:function(){return t.arrayStyle("flex-end")}},"Lower (Traditional)")),a.a.createElement("div",{id:"algorithm_info"}))}},{key:"newArray",value:function(){this.enableButtons();for(var t,e,n=[],r=0;r<200;r++)n.push((t=10,e=200,Math.floor(Math.random()*(e-t+1)+t)));this.setState({array:n})}},{key:"arrayStyle",value:function(t){document.getElementById("array_area").style.alignItems=t}},{key:"disableButtons",value:function(){for(var t=["shuffle","quick","merge","insertion","bubble","heap","selection"],e=0;e<t.length;e++)document.getElementById(t[e]).disabled=!0;document.getElementById("skip").disabled=!1}},{key:"enableButtons",value:function(){for(var t=["shuffle","quick","merge","insertion","bubble","heap","selection"],e=0;e<t.length;e++)document.getElementById(t[e]).disabled=!1;document.getElementById("skip").disabled=!0}},{key:"skipAnimations",value:function(){for(var t=0;t<f.length;t++)clearTimeout(f[t]);f=[];for(var e,n=(d(e=this.state.array,0,e.length-1,[]),e),r=document.getElementsByClassName("array_element"),a=0;a<r.length;a++)r[a].style.backgroundColor="burlywood",r[a].style.height="".concat(2*n[a],"px");this.setState({sortedArray:n}),this.enableButtons()}}]),n}(a.a.Component);n(15);var v=function(){return a.a.createElement("div",{className:"App"},a.a.createElement("h1",null,"Visualizing Sorting Algorithms"),a.a.createElement(y,null))};Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));o.a.render(a.a.createElement(a.a.StrictMode,null,a.a.createElement(v,null)),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(t){t.unregister()})).catch((function(t){console.error(t.message)}))}],[[8,1,2]]]);
//# sourceMappingURL=main.65aa1cdc.chunk.js.map