{"version":3,"sources":["SortingAlgorithms/MergeSort.js","SortingAlgorithms/QuickSort.js","SortingAlgorithms/HeapSort.js","SortingHome/SortingHome.jsx","SortingAlgorithms/InsertionSort.js","SortingAlgorithms/BubbleSort.js","SortingAlgorithms/SelectionSort.js","App.js","serviceWorker.js","index.js"],"names":["animateMergeSort","stateArray","animationsArray","tempArray","slice","mergeHelper","start","end","mid","Math","floor","i","j","k","push","mergeAnimations","length","quickHelper","array","partition","pivotElement","temp","newTemp","partitionHelper","animateHeapSort","heapify","heapHelper","root","left_child","right_child","TIMEOUT_ARRAY","SortingHome","props","state","this","newArray","disableButtons","document","getElementById","innerHTML","animateQuickSort","arrayElements","getElementsByClassName","keyword","element1","element2","singleElementHighlight","singleElementUnHighlight","element1Height","element2Height","elementSwap","completeSorting","element1Style","style","element2Style","setTimeout","backgroundColor","element1height","height","current","insertionHelper","animateInsertionSort","swapHappened","bubbleHelper","animateBubbleSort","current_min","min_value","selectionHelper","animateSelectionSort","highlightColor","enableButtons","className","id","onClick","quickSort","mergeSort","insertionSort","bubbleSort","heapSort","selectionSort","skipAnimations","alignItems","map","value","idx","key","arrayStyle","lower","upper","random","setState","styleChange","list","disabled","clearTimeout","sortedArray","React","Component","App","href","target","rel","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.0338589c.chunk.js","sourcesContent":["// Created by Zaddeen Benaissa, July 2020.\n\n// Returns the animationsArray to the main function in SortingHome.\n// Calls the mergeHelper function.\nexport function animateMergeSort (stateArray) {\n    const animationsArray = [];\n    const tempArray = stateArray.slice();\n    const final = stateArray.length - 1;\n    mergeHelper(stateArray, tempArray, animationsArray, 0, final);\n    return animationsArray;\n}\n\n// This function is the same as the first portion of merge sort - recursively divide\n// the array into two pieces until we reach single elements, at which point we begin \n// to make comparisons.\nfunction mergeHelper (\n    stateArray, \n    tempArray, \n    animationsArray, \n    start, \n    end\n) {\n    if (start === end) {\n        return;\n    }\n    const mid = Math.floor((start + end) / 2);\n    // Recurse on the first half of the array.\n    mergeHelper(tempArray, stateArray, animationsArray, start, mid);\n    // Recuse on the second half of the array.\n    mergeHelper(tempArray, stateArray, animationsArray, mid + 1, end);\n    // Perform the sorting operations.\n    mergeAnimations(stateArray, tempArray, animationsArray, start, mid, end)\n}\n\n// This function is the second portion of the merge sort algorithm - we compare elements\n// and sort them as necessary. In this case, we are sorting the tempArray and storing the\n// necessary animations in the animationsArray.\nfunction mergeAnimations (\n    stateArray,\n    tempArray,\n    animationsArray,\n    start,\n    mid,\n    end\n) {\n    let i = start, j = mid + 1, k = start;\n    while (i <= mid && j <= end) {\n        animationsArray.push([\"comparison\", i, j]);\n        animationsArray.push([\"finish_compare\", i, j]);\n        // If array[i] <= array[j], array[i] goes first.\n        if (tempArray[i] <= tempArray[j]) {\n          animationsArray.push([\"swap\", i, k]);\n          animationsArray.push([\"swap2\", tempArray[i], stateArray[k]]);\n          stateArray[k++] = tempArray[i++];\n        }\n        // Otherwise, array[j] goes first.\n        else {\n          animationsArray.push([\"swap\", j, k]);\n          animationsArray.push([\"swap2\", tempArray[j], stateArray[k]]);\n          stateArray[k++] = tempArray[j++];\n        }\n    }\n    // If there are any leftover items in the left/right halves, we now push them\n    // in order into the new array (since we know they must already be sorted).\n    while (i <= mid) {\n        animationsArray.push([\"swap\", i, k]);\n        animationsArray.push([\"swap2\", tempArray[i], stateArray[k]]);\n        stateArray[k++] = tempArray[i++];\n    }\n\n    while (j <= end) {\n        animationsArray.push([\"swap\", j, k]);\n        animationsArray.push([\"swap2\", tempArray[j], stateArray[k]]);\n        stateArray[k++] = tempArray[j++];\n    }\n}","// Created by Zaddeen Benaissa, July 2020.\n\n// Returns the animationsArray to the main function in SortingHome.\n// Calls the quickHelper function.\nexport function animateQuickSort (stateArray) {\n    const animationsArray = [];\n    quickHelper(stateArray, 0, stateArray.length-1, animationsArray);\n    return animationsArray;\n}\n\n// Helper function to perform Quicksort.\n// Calls the partition function and recursively calls itself with smaller\n// partitions of the array.\nfunction quickHelper(array, start, end, animationsArray) {\n    if (start < end) {\n        const partition = partitionHelper(array, start, end, animationsArray);\n        quickHelper(array, start, partition-1, animationsArray);\n        quickHelper(array, partition+1, end, animationsArray);\n    }\n}\n// The partition function for Quicksort. \n// This function chooses a pivot element and sorts elements around it, and while\n// doing so it a) pushes animations to animationsArray and b) sorts the given \n// array accordingly.\nfunction partitionHelper(array, start, end, animationsArray) {\n    let i = start-1;\n    // Here we use the final entry as the pivot - but using any entry would be valid.\n    // Other implementations use the start, middle, or even randomized entries.\n    const pivotElement = array[end];\n    animationsArray.push([\"pivot_highlight\", end, end])\n    for (let j = start; j < end; j+=1) {\n        // If an element is less than the pivot, we place it at the leftmost available\n        // spot in the array. We don't care if the entries are in order right now,\n        // we only examine if they are less/greater than the pivot value.\n        if (array[j] < pivotElement) {\n            i += 1;\n            animationsArray.push([\"swap_compared\", i, j]);\n            animationsArray.push([\"swap_elements\", array[i], array[j]]);\n            const temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n        }\n    }\n    animationsArray.push([\"pivot_unhighlight\", end, end]);\n    animationsArray.push([\"swap_compared\", end, i + 1]);\n    animationsArray.push([\"swap_elements\", array[end], array[i + 1]]);\n    // We finish by swapping the final entry in the array with the our recorded\n    // \"ith\" value - this is because the final entry is the pivot, so this swap ensures\n    // that everything to the left is smaller than the pivot and everything to the\n    // right is larger!\n    const newTemp = array[end];\n    array[end] = array[i+1];\n    array[i+1] = newTemp;\n    return (i+1);\n}\n\n// Produces the sorted array for Quicksort.\n// Also calls the quickSortHelper function - but instead of returning\n// animationsArray, it simply returns the (now sorted) array.\nexport function quick_sort(array) {\n    const animationsArray = [];\n    quickHelper(array, 0, array.length-1, animationsArray);\n    return array;\n}","// Created by Zaddeen Benaissa, July 2020.\n\n// Returns the animationsArray to the main function in SortingHome.\n// Calls the heapHelper function.\nexport function animateHeapSort(stateArray) {\n    const animationsArray = [];\n    heapHelper(animationsArray, stateArray);\n    return animationsArray;\n}\n\n// The parent function for the Heapsort algorithm. First calls the Heapify\n// function in a loop in order to construct a Max Heap data structure, and then\n// makes sure that the invariant is preserved with the second loop.\nfunction heapHelper(animationsArray, stateArray) {\n    const length = stateArray.length;\n    const mid = Math.floor((length / 2) - 1);\n    // Constructs the max heap.\n    for (let i = mid; i >= 0; i--) {\n        heapify(animationsArray, stateArray, length, i);\n    }\n    // Ensures that the heap invariant is preserved.\n    for (let i = length-1; i > 0; i--) {\n        animationsArray.push([\"swap\", i, 0]);\n        animationsArray.push([\"heights\", stateArray[i], stateArray[0]]);\n        const temp = stateArray[i];\n        stateArray[i] = stateArray[0];\n        stateArray[0] = temp;\n        heapify(animationsArray, stateArray, i, 0);\n    }\n}\n\n// The Heapify function for the Heapsort algorithm. This is a simple in-place\n// function to construct the Heap, it compares elements with \"children\"\n// to ensure that the Heap has been constructed properly (also recursively\n// calls itself if needed).\nfunction heapify(animationsArray, stateArray, length, i) {\n    // Calculate the position of the children of the root.\n    var root = i;\n    const left_child = 2*i + 1;\n    const right_child = 2*i + 2;\n    // If either child is larger than the root, we will need to Heapify the heap. \n    if (left_child < length && stateArray[root] < stateArray[left_child]) {\n        root = left_child;\n    }\n\n    if (right_child < length && stateArray[root] < stateArray[right_child]) {\n        root = right_child;\n    }\n    // If we do have a size problem, we swap the root with the ith element and heapify.\n    if (root !== i) {\n        animationsArray.push([\"swap\", i, root]);\n        animationsArray.push([\"heights\", stateArray[i], stateArray[root]]);\n        const temp = stateArray[root];\n        stateArray[root] = stateArray[i];\n        stateArray[i] = temp;\n        heapify(animationsArray, stateArray, length, root);\n    }\n}","// Created by Zaddeen Benaissa, July 2020.\n\nimport React from 'react';\nimport './SortingHome.css';\nimport {animateMergeSort} from '../SortingAlgorithms/MergeSort.js'\nimport {animateQuickSort, quick_sort} from \"../SortingAlgorithms/QuickSort.js\";\nimport {animateInsertionSort} from \"../SortingAlgorithms/InsertionSort.js\";\nimport {animateBubbleSort} from \"../SortingAlgorithms/BubbleSort.js\";\nimport {animateHeapSort} from \"../SortingAlgorithms/HeapSort.js\";\nimport {animateSelectionSort} from \"../SortingAlgorithms/SelectionSort.js\";\n\n// A few global constants, placed first so that they are easily \n// modifiable if needed.\nconst ORIGINAL_ELEMENT_COLOR = \"burlywood\";\nconst CHANGED_ELEMENT_COLOR = \"blue\";\nconst SORTING_SPEED = 3;\nconst ELEMENTS_PER_ARRAY = 150;\n\n// This allows us to store all the animations in one place - \n// this is helpful when we are trying to skip past them.\nvar TIMEOUT_ARRAY = [];\n\nexport default class SortingHome extends React.Component {\n    // Initializes the state to an empty array, allows for later re-assignment.\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            array: [],\n        };\n    }\n\n    // Initializes a new array of randomized entries.\n    componentDidMount() {\n        this.newArray();\n    }\n\n    //\n    // SORTING ALGORITHM FUNCTIONS:\n    //\n\n    // General Guide:\n\n    // Each sorting function has a very similar structure: they are called on the state\n    // array if their respective button is clicked, and they each start by calling an external\n    // helper function. The helper function sorts the state array, but at the same time it records\n    // animations of relevant parts (swapping two elements, selecting a new minimum) within the\n    // \"animationsArray\". The information stored in animationsArray is then used in order to\n    // create the visual animations that are seen in real time (as the actual sort takes fractions\n    // of a second). The animations conclude with the sorted array, at which point the function\n    // highlights every element green (in order) and returns button functionality to the user.\n\n    // Animations Explained:\n\n    // Animations are read from the animationsArray in the following style:\n    // const [keyword, element1, element2] = animationsArray[i];\n    // Where {keyword} is a string that indicates the animation type. \n    // 1. If {keyword} is either \"highlight\" or \"unhighlight\", then element1 and element2 are both \n        // simply the index of the element that we want to change - and we call the corresponding function \n        // to change/revert their color color.\n    // 2. If {keyword} is \"swap\", then element1 and element2 are the indices of the swapped elements,\n        // and animationsArray[i+1] (the directly following entry) contains the heights of the two\n        // elements. We can then pass this to this.elementSwap() to animate the swap.\n    // Note: The animations are really just CSS style changes to either \"height\" or \"backgroundColor\".\n    \n    // Quick Sort.\n    // The full algorithm description can be found in SortingAlgorithms/QuickSort.js.\n    quickSort() {\n        this.disableButtons();\n        const algDescription = document.getElementById(\"algorithm_info\");\n        algDescription.innerHTML = \n        `<h2 id=\"algorithm_title\"> Algorithm: Quicksort</h2>\n        <h4> (Scroll down for more info!) </h4>\n            <p> Quicksort relies primarily on the idea of the \"partition algorithm\" - the algorithm\n                selects a pivot element within the array and places it in its correct position\n                in the sorted array. In the process, the algorithm ensures that every element to the\n                left of the pivot is smaller than it is, and every element to the right of the\n                pivot is larger than it is. By repeating this process on each pair of left and right\n                partitions, we successfully sort the entire array. </p>\n        <h2> Time Complexity </h2>\n        <div id=\"complexity_table\">\n            <table>\n                <tr>\n                    <td> Worst Case </td>\n                    <td> O(n<sup>2</sup>) </td>\n                </tr>\n                <tr>\n                    <td> Average Case </td>\n                    <td> O(nlog(n)) </td>\n                </tr>\n                <tr>\n                    <td> Best Case </td>\n                    <td> O(nlog(n)) </td>\n                </tr>\n            </table>\n        </div>\n        <p> Note: Even though Quicksort runs in O(n<sup>2</sup>) time in the worst case,\n            it almost never runs this slow due to the many ways a pivot can be selected\n            (first element, last element, random element, etc). Because it almost never runs\n            in the worst case time it is quite popular, and the fact that it often runs much \n            faster than alternative algorithms explains its namesake! </p>`;\n        TIMEOUT_ARRAY = [];\n        const animationsArray = animateQuickSort(this.state.array);\n        let i = 0;\n        const arrayElements = document.getElementsByClassName(\"array_element\");\n        while (i < animationsArray.length) {\n            const [keyword, element1, element2] = animationsArray[i];\n            // Highlight pivot elements\n            if (keyword === \"pivot_highlight\") {\n                this.singleElementHighlight(arrayElements, element1, i, \"red\");\n                i++;\n            }\n            // Unhighlight pivot element (often after many swaps).\n            else if (keyword === \"pivot_unhighlight\") {\n                this.singleElementUnHighlight(arrayElements, element1, i);\n                i++;\n            }\n            // Swap the two compared elements.\n            else if (keyword === \"swap_compared\") {\n                const [, element1Height, element2Height] = animationsArray[i+1];\n                this.elementSwap(arrayElements, element1, element1Height, element2, element2Height, i)\n                i += 2;\n            }\n        }\n        this.completeSorting(i, arrayElements);\n    }\n\n    // Merge Sort. \n    // The full algorithm description can be found in SortingAlgorithms/MergeSort.js.\n    mergeSort() {\n        this.disableButtons();\n        const algDescription = document.getElementById(\"algorithm_info\");\n        algDescription.innerHTML = \n        `<h2 id=\"algorithm_title\"> Algorithm: Merge Sort</h2>\n        <h4> (Scroll down for more info!) </h4> \n            <p>Merge Sort works by recursively splitting the array in half until we reach\n                a single element, at which point we begin comparing element by element.\n                This allows each portion of the array to be sorted in a row, which explains\n                the \"chunks\" that you can see while the algorithm runs. </p>\n        <h2> Time Complexity </h2>\n        <div id=\"complexity_table\">\n            <table>\n                <tr>\n                    <td> Worst Case </td>\n                    <td> O(nlog(n)) </td>\n                </tr>\n                <tr>\n                    <td> Average Case </td>\n                    <td> O(nlog(n)) </td>\n                </tr>\n                <tr>\n                    <td> Best Case </td>\n                    <td> O(nlog(n)) </td>\n                </tr>\n            </table>\n        </div>\n        <p> Note: Merge Sort always runs in the same time - O(nlog(n)) - due to the fact that \n            it separates the array in half every time, no matter what. This makes it quite \n            effective for larger arrays/lists, as you can guarantee a fast run time. </p>`;\n        TIMEOUT_ARRAY = [];\n        const animationsArray = animateMergeSort(this.state.array);\n        let i = 0;\n        const arrayElements = document.getElementsByClassName(\"array_element\");\n        while (i < animationsArray.length) {\n            const [keyword, element1, element2] = animationsArray[i];\n            // Highlight, then unhighlight the compared items.\n            if (keyword === \"comparison\") {\n                this.singleElementHighlight(arrayElements, element1, i, CHANGED_ELEMENT_COLOR);\n                this.singleElementHighlight(arrayElements, element2, i, CHANGED_ELEMENT_COLOR);\n                this.singleElementUnHighlight(arrayElements, element1, i+1, CHANGED_ELEMENT_COLOR);\n                this.singleElementUnHighlight(arrayElements, element2, i+1, CHANGED_ELEMENT_COLOR);\n            }\n            // Merge Sort has a special swap animation - since it is not sorting in place,\n            // we only change the height of one of the entries (copy it over).\n            else if (keyword === \"swap\") {\n                const element1Style = arrayElements[element1].style;\n                const element2Style = arrayElements[element2].style;\n                // Color change.\n                TIMEOUT_ARRAY.push(\n                  setTimeout(() => {\n                    element1Style.backgroundColor = CHANGED_ELEMENT_COLOR;\n                    element2Style.backgroundColor = CHANGED_ELEMENT_COLOR;\n                  }, i * SORTING_SPEED)\n                );\n                const [, element1height] = animationsArray[i + 1];\n                // Height change (not the same as other swaps) and color revert.\n                TIMEOUT_ARRAY.push(\n                  setTimeout(() => {\n                    //element1Style.height = `${2 * element2height}px`;\n                    element2Style.height = `${2 * element1height}px`;\n                    element1Style.backgroundColor = ORIGINAL_ELEMENT_COLOR;\n                    element2Style.backgroundColor = ORIGINAL_ELEMENT_COLOR;\n                  }, (i + 1) * SORTING_SPEED)\n                );\n            }\n            i += 2;\n        }\n        this.completeSorting(i, arrayElements);\n    }\n\n    // Insertion Sort.\n    // The full algorithm description can be found in SortingAlgorithms/InsertionSort.js.\n    insertionSort () {\n        this.disableButtons();\n        const algDescription = document.getElementById(\"algorithm_info\");\n        algDescription.innerHTML = \n        `<h2 id=\"algorithm_title\"> Algorithm: Insertion Sort </h2>\n        <h4> (Scroll down for more info!) </h4> \n            <p> Insertion Sort is one of the simpler sorting algorithms: it iterates across the full\n                array and sorts it one element at a time, guaranteeing that the first n+1 elements are\n                sorted on the \"nth\" iteration. Though usually inefficient, its advantages are in the fact\n                that it is not difficult to implement and that it requires no additional space to sort.</p>\n        <h2> Time Complexity </h2>\n        <div id=\"complexity_table\">\n            <table>\n                <tr>\n                    <td> Worst Case </td>\n                    <td> O(n<sup>2</sup>) </td>\n                </tr>\n                <tr>\n                    <td> Average Case </td>\n                    <td> O(n<sup>2</sup>) </td>\n                </tr>\n                <tr>\n                    <td> Best Case </td>\n                    <td> O(n) </td>\n                </tr>\n            </table>\n        </div>\n        <p> Note: Insertion Sort is quite slow on large arrays, but its saving grace is that\n            it has O(n) runtime on sorted arrays. So, on very small arrays (<10 entries), Insertion\n            Sort can outperform almost every other Sorting Algorithm! In fact, some versions of Quick Sort\n            actually use Insertion Sort as array partitions approach this size!</p>`;\n        TIMEOUT_ARRAY = [];\n        const animationsArray = animateInsertionSort(this.state.array);\n        let i = 0;\n        const arrayElements = document.getElementsByClassName(\"array_element\");\n        while (i < animationsArray.length) {\n            const [keyword, element1, element2] = animationsArray[i];\n            // Swap the two compared elements.\n            if (keyword === \"swap\") {\n                const [, element1Height, element2Height] = animationsArray[i+1];\n                this.elementSwap(arrayElements, element1, element1Height, element2, element2Height, i)\n                i += 2;\n            }\n\n            else if (keyword === \"reassign\") {\n                const element1Style = arrayElements[element1].style;\n                TIMEOUT_ARRAY.push(\n                  setTimeout(() => {\n                    element1Style.height = `${2*element2}px`;\n                  }, i * SORTING_SPEED)\n                );\n                i += 1;\n            }\n        }\n        this.completeSorting(i, arrayElements);\n    }\n\n    // Bubble Sort.\n    // The full algorithm description can be found in SortingAlgorithms/BubbleSort.js.\n    bubbleSort() {\n        this.disableButtons();\n        const algDescription = document.getElementById(\"algorithm_info\");\n        algDescription.innerHTML = \n        `<h2 id=\"algorithm_title\"> Algorithm: Bubble Sort</h2>\n        <h4> (Scroll down for more info!) </h4>\n            <p> Bubble Sort is the most simple sorting algorithm, usually used more to teach\n                concepts than to effectively sort arrays. It works by comparing each pair of elements,\n                swapping if they are in the wrong order. This guarantees that the final n elements\n                will be sorted on the \"nth\" pass through the array, but can lead to extremely\n                slow sorting times.</p>\n        <h2> Time Complexity </h2>\n        <div id=\"complexity_table\">\n            <table>\n                <tr>\n                    <td> Worst Case </td>\n                    <td> O(n<sup>2</sup>) </td>\n                </tr>\n                <tr>\n                    <td> Average Case </td>\n                    <td> O(n<sup>2</sup>) </td>\n                </tr>\n                <tr>\n                    <td> Best Case </td>\n                    <td> O(n) </td>\n                </tr>\n            </table>\n        </div>\n        <p> Note: Bubble Sort, similar to Insertion Sort, also runs in O(n) time when the \n            array is already sorted. As a result it can also be used on mostly sorted arrays, \n            but Insertion Sort is often preferred. </p>`;\n        TIMEOUT_ARRAY = [];\n        const animationsArray = animateBubbleSort(this.state.array);\n        let i = 0;\n        const arrayElements = document.getElementsByClassName(\"array_element\");\n        while (i < animationsArray.length) {\n            const [keyword, element1, element2] = animationsArray[i];\n            if (keyword === \"swap\") {\n                const [, element1Height, element2Height] = animationsArray[i+1];\n                this.elementSwap(arrayElements, element1, element1Height, element2, element2Height, i)\n                i += 2;\n            }\n        }\n        this.completeSorting(i, arrayElements);\n    }\n\n    // Heapsort.\n    // The full algorithm description can be found in SortingAlgorithms/HeapSort.js.\n    heapSort() {\n        this.disableButtons();\n        const algDescription = document.getElementById(\"algorithm_info\");\n        algDescription.innerHTML = \n        `<h2 id=\"algorithm_title\"> Algorithm: Heapsort</h2>\n        <h4> (Scroll down for more info!) </h4>\n            <p> Heapsort sorts by first constructing a Max Heap data structure, and then afterwards\n                makes sure that the Heap invariant is preserved - this invariant being the idea that\n                if one node is a parent of another, the parent value is greater than or equal to\n                the child value. This causes the array to become sorted from back to front, as the \n                largest values are processed first (as parent nodes) followed by the smaller ones (children). </p>\n        <h2> Time Complexity </h2>\n        <div id=\"complexity_table\">\n            <table>\n                <tr>\n                    <td> Worst Case </td>\n                    <td> O(nlog(n)) </td>\n                </tr>\n                <tr>\n                    <td> Average Case </td>\n                    <td> O(nlog(n)) </td>\n                </tr>\n                <tr>\n                    <td> Best Case </td>\n                    <td> O(nlog(n)) </td>\n                </tr>\n            </table>\n        </div>\n        <p> Note: Though Heapsort itself is not popular in comparison with strong alternatives\n            like Quick Sort or Merge Sort, it is quite useful because it produces a Heap, which\n            has lots of uses in Computer Science (including Djikstra's algorithm for path-finding).\n            Additionally, though Quick Sort is almost always faster, the fact that its worst case runtime\n            is O(n<sup>2</sup>) makes Heapsort a much better option when maximum time is a real concern. </p>`;\n        TIMEOUT_ARRAY = [];\n        const animationsArray = animateHeapSort(this.state.array);\n        let i = 0;\n        const arrayElements = document.getElementsByClassName(\"array_element\");\n        while (i < animationsArray.length) {\n            const [keyword, element1, element2] = animationsArray[i];\n            if (keyword === \"swap\") {\n                const [, element1Height, element2Height] = animationsArray[i+1];\n                this.elementSwap(arrayElements, element1, element1Height, element2, element2Height, i);\n                i += 2;\n            }\n            \n        }\n        this.completeSorting(i, arrayElements);\n    }\n\n    // Selection Sort.\n    // The full algorithm description can be found in SortingAlgorithms/SelectionSort.js.\n    selectionSort() {\n        this.disableButtons();\n        const algDescription = document.getElementById(\"algorithm_info\");\n        algDescription.innerHTML = \n        `<h2 id=\"algorithm_title\"> Algorithm: Selection Sort</h2>\n        <h4> (Scroll down for more info!) </h4>\n            <p> Selection Sort sorts by dividing the array into two parts: on the \"nth\"\n                pass through the array, the first n items are sorted, and the remaining\n                subarray (everything to the right of entry n) are not. It works by\n                calculating the minimum remaining entry in the unsorted subarray and \n                moving it to the end of the sorted subarray, until the entire array is sorted.</p>\n        <h2> Time Complexity </h2>\n        <div id=\"complexity_table\">\n            <table>\n                <tr>\n                    <td> Worst Case </td>\n                    <td> O(n<sup>2</sup>) </td>\n                </tr>\n                <tr>\n                    <td> Average Case </td>\n                    <td> O(n<sup>2</sup>) </td>\n                </tr>\n                <tr>\n                    <td> Best Case </td>\n                    <td> O(n<sup>2</sup>) </td>\n                </tr>\n            </table>\n        </div>\n        <p> Note: Selection Sort runs in O(n<sup>2</sup>) time no matter what. However, it \n            can be preferred in certain situations due to the fact that it makes n-1 swaps\n            in the worst case. This is paired with the fact that Selection Sort sorts in place \n            (no extra required). So, if memory is an issue, it is quite handy! </p>`;\n        TIMEOUT_ARRAY = [];\n        const animationsArray = animateSelectionSort(this.state.array);\n        let i = 0;\n        const arrayElements = document.getElementsByClassName(\"array_element\");\n        while (i < animationsArray.length) {\n            const [keyword, element1, element2] = animationsArray[i];\n            if (keyword === \"swap\") {\n                const [, element1Height, element2Height] = animationsArray[i+1];\n                this.elementSwap(arrayElements, element1, element1Height, element2, element2Height, i);\n                i += 2;\n            }\n            else if (keyword === \"current_highlight\") {\n                this.singleElementHighlight(arrayElements, element1, i, CHANGED_ELEMENT_COLOR);\n                i++;\n            }\n            else if (keyword === \"current_unhighlight\") {\n                this.singleElementUnHighlight(arrayElements, element1, i);\n                i++;\n            }\n        }\n        this.completeSorting(i, arrayElements);\n    }\n\n    //\n    // ANIMATION FUNCTIONS\n    //\n\n     // Animation for highlighting a single array element, also takes color as input.\n     // We store the animation within the TIMEOUT_ARRAY in case we want to skip it.\n    singleElementHighlight(arrayElements, element1, i, highlightColor) {\n        const element1Style = arrayElements[element1].style;\n        TIMEOUT_ARRAY.push(\n          setTimeout(() => {\n            element1Style.backgroundColor = highlightColor;\n          }, i * SORTING_SPEED)\n        );\n    }\n\n    // Animation for unhighlighting a single array element (change color to original).\n    // We store the animation within the TIMEOUT_ARRAY in case we want to skip it.\n    singleElementUnHighlight(arrayElements, element1, i) {\n        const element1Style = arrayElements[element1].style;\n        TIMEOUT_ARRAY.push(\n          setTimeout(() => {\n            element1Style.backgroundColor = ORIGINAL_ELEMENT_COLOR;\n          }, i * SORTING_SPEED)\n        );\n    }\n\n    // Animation for highlighting and swapping two array elements.\n    // The swap animation has a few parts:\n        // 1. Highlight the two elements to be swapped (change their color).\n        // 2. Swap the two elements heights.\n        // 3. Revert the two elements' colors.\n    // We store the animations within the TIMEOUT_ARRAY in case we want to skip it.\n    elementSwap(arrayElements, element1, element1Height, element2, element2Height, i) {\n        const element1Style = arrayElements[element1].style;\n        const element2Style = arrayElements[element2].style;\n        // Color change.\n        TIMEOUT_ARRAY.push(\n          setTimeout(() => {\n            element1Style.backgroundColor = CHANGED_ELEMENT_COLOR;\n            element2Style.backgroundColor = CHANGED_ELEMENT_COLOR;\n          }, i * SORTING_SPEED)\n        );\n        // Height swap and color revert.\n        TIMEOUT_ARRAY.push(\n          setTimeout(() => {\n            element1Style.height = `${2 * element2Height}px`;\n            element2Style.height = `${2 * element1Height}px`;\n            element1Style.backgroundColor = ORIGINAL_ELEMENT_COLOR;\n            element2Style.backgroundColor = ORIGINAL_ELEMENT_COLOR;\n          }, (i + 1) * SORTING_SPEED)\n        );\n    }\n\n    // Re-enables button functionality once the animations are complete.\n    completeSorting(i, arrayElements) {\n        for (let j = 0; j < arrayElements.length; j++) {\n            this.singleElementHighlight(arrayElements, j, i+j+1, \"rgb(48, 150, 48)\");\n        }\n        for (let k = 0; k < arrayElements.length; k++) {\n            this.singleElementUnHighlight(arrayElements, k, i+arrayElements.length+1);\n        }\n        TIMEOUT_ARRAY.push(\n          setTimeout(() => {\n            this.enableButtons();\n          }, (i + arrayElements.length + 1) * SORTING_SPEED)\n        );\n        \n    }\n\n    //\n    // MAIN RENDER FUNCTION:\n    //\n\n    // Renders the current state - this includes the sort buttons, array visualization, display toggle,\n    // and algorithm descriptions.\n    render() {\n        const {array} = this.state;\n        return (\n          <>\n            <div className=\"buttons\">\n              <button id=\"shuffle\" onClick={() => this.newArray()}>\n                Shuffle Array\n              </button>\n              <button id=\"quick\" onClick={() => this.quickSort()}>\n                Quicksort\n              </button>\n              <button id=\"merge\" onClick={() => this.mergeSort()}>\n                Merge Sort\n              </button>\n              <button id=\"insertion\" onClick={() => this.insertionSort()}>\n                Insertion Sort\n              </button>\n              <button id=\"bubble\" onClick={() => this.bubbleSort()}>\n                Bubble Sort\n              </button>\n              <button id=\"heap\" onClick={() => this.heapSort()}>\n                Heapsort\n              </button>\n              <button id=\"selection\" onClick={() => this.selectionSort()}>\n                Selection Sort\n              </button>\n              <button id=\"skip\" onClick={() => this.skipAnimations()}>\n                {\" \"}\n                Skip{\" \"}\n              </button>\n            </div>\n\n            <div id=\"array_area\" style={{ alignItems: \"center\" }}>\n              {array.map((value, idx) => (\n                <div\n                  className=\"array_element\"\n                  key={idx}\n                  style={{ height: `${2 * value}px` }}\n                ></div>\n              ))}\n            </div>\n            <div className=\"stylebuttons\">\n              <h3> Toggle Array Orientation </h3>\n              <button onClick={() => this.arrayStyle(\"flex-start\")}>\n                Upper (Icicles)\n              </button>\n              <button onClick={() => this.arrayStyle(\"center\")}>\n                Middle (Signal)\n              </button>\n              <button onClick={() => this.arrayStyle(\"flex-end\")}>\n                Lower (Traditional)\n              </button>\n            </div>\n            <div id=\"algorithm_info\"></div>\n          </>\n        );\n    }\n\n    //\n    // HELPER FUNCTIONS:\n    //\n\n    // Creates a new array of random numbers - convenient for the \"reset array\" feature.\n    newArray() {\n        this.enableButtons();\n        const array = [];\n        for (let i = 0; i < ELEMENTS_PER_ARRAY; i++) {\n            array.push(randomIntGenerator(10, 200));\n        }\n        this.setState({array});\n    }\n\n    // Changes the style of the array depending on which style button has been selected.\n    // Possible options are : upper (\"flex-start\"), center (\"center\"), and lower (\"flex-end\").\n    arrayStyle(styleChange) {\n        const arrayAreaStyle = document.getElementById(\"array_area\").style;\n        arrayAreaStyle.alignItems = styleChange;\n    }\n\n    // Disables all sorting/shuffle button functionality. Enables skip.\n    disableButtons() {\n        var list = [\n          \"shuffle\",\n          \"quick\",\n          \"merge\",\n          \"insertion\",\n          \"bubble\",\n          \"heap\",\n          \"selection\"\n        ];\n        for (let i = 0; i < list.length; i++) {\n          document.getElementById(list[i]).disabled = true;\n        }\n        document.getElementById(\"skip\").disabled = false;\n    }\n\n    // Re-enables all sorting/shuffle button functionality. Disables skip.\n    enableButtons() {\n        var list = [\n          \"shuffle\",\n          \"quick\",\n          \"merge\",\n          \"insertion\",\n          \"bubble\",\n          \"heap\",\n          \"selection\"\n        ];\n        for (let i = 0; i < list.length; i++) {\n          document.getElementById(list[i]).disabled = false;\n        }\n        document.getElementById(\"skip\").disabled = true;\n    }\n    \n    // Skips the sorting animations and displays the sorted array (re-enables buttons if disabled).\n    skipAnimations() {\n        for (let i=0; i<TIMEOUT_ARRAY.length; i++) {\n            clearTimeout(TIMEOUT_ARRAY[i]);\n        }\n        TIMEOUT_ARRAY = [];\n        const sortedArray = quick_sort(this.state.array);\n        const arrayElements = document.getElementsByClassName(\"array_element\");\n        for (let i=0; i<arrayElements.length; i++) {\n            arrayElements[i].style.backgroundColor = ORIGINAL_ELEMENT_COLOR;\n            arrayElements[i].style.height = `${2*sortedArray[i]}px`;\n        }\n        this.setState({ sortedArray });\n        this.enableButtons();\n    }\n}\n\n// This function was found on StackOverflow, thanks to everyone involved.\n// https://stackoverflow.com/questions/1527803/generating-random-whole-numbers-in-javascript-in-a-specific-range\nfunction randomIntGenerator(lower, upper) {\n    return Math.floor(Math.random() * (upper - lower + 1) + lower);\n}","// Created by Zaddeen Benaissa, July 2020.\n\n// Returns the animationsArray to the main function in SortingHome.\n// Calls the insertionHelper function.\nexport function animateInsertionSort(stateArray) {\n    const animationsArray = [];\n    insertionHelper(stateArray, animationsArray);\n    return animationsArray;\n}\n// Runs the Insertion Sort algorithm and records the animations.\n// These are simply:\n// 1. Swap element with its neighbor (moving it to the left).\n// 2. Reassign a value (usually unnecessary, but particularly needed for edge cases).\n// This sorts the stateArray and pushes to the animationsArray.\nfunction insertionHelper (stateArray, animationsArray) {\n    for (let i = 1; i < stateArray.length; i++) {\n        const current = stateArray[i];\n        let j = i - 1;\n        while (j >= 0 && current < stateArray[j]) {\n            // Within this loop, we move small elements leftward until they are smaller\n            // than anything on their right but larger than anything on their left.\n            animationsArray.push([\"swap\", j+1, j]);\n            animationsArray.push([\"swap2\", stateArray[j+1], stateArray[j]]);\n            stateArray[j + 1] = stateArray[j];\n            j -= 1;\n        }\n        // Now that we have moved an entry as much as we can, we do one final swap\n        // to ensure it is in place.\n        animationsArray.push([\"reassign\", j+1, current]);\n        stateArray[j + 1] = current;\n    }\n}","// Created by Zaddeen Benaissa, July 2020.\n\n// Returns the animationsArray to the main function in SortingHome.\n// Calls the bubbleHelper function.\nexport function animateBubbleSort(stateArray) {\n    const animationsArray = [];\n    bubbleHelper(animationsArray, stateArray);\n    return animationsArray;\n}\n\n// Runs Bubble Sort and returns the animations. \n// We iterate over the entire array and sort the elements pairwise - \n    // if one is larger than the other, it is moved to the right.\n    // This guarantees that the last i elements are sorted on the ith pass.\n//\n// The only animations for this process are the swaps each time - we don't need to\n// animate every comparison that occurs, just successful ones. This Bubble Sort \n// implementation has also been slightly optimized - if we don't make a swap on \n// a pass through the array, we know we have finished sorting so we stop.\nfunction bubbleHelper(animationsArray, stateArray) {\n    const length = stateArray.length;\n    for (let i = 0; i < length; i++) {\n        // Assume a swap has not happened. If this holds, break out of the loop.\n        var swapHappened = false;\n        for (let j = 0; j < length - i - 1; j++) {\n            // If two elements are out of order, swap them. Set swapHappened = true.\n            if (stateArray[j] > stateArray[j + 1]) {\n                animationsArray.push([\"swap\", j, j+1]);\n                animationsArray.push([\"heights\", stateArray[j], stateArray[j+1]]);\n                const temp = stateArray[j + 1];\n                stateArray[j + 1] = stateArray[j];\n                stateArray[j] = temp;\n                swapHappened = true;\n            }\n        }\n    if (!swapHappened) {break;}\n    }\n}","// Created by Zaddeen Benaissa, July 2020.\n\n// Returns the animationsArray to the main function in SortingHome.\n// Calls the selectionHelper function.\nexport function animateSelectionSort(stateArray) {\n    const animationsArray = [];\n    selectionHelper(stateArray, animationsArray);\n    return animationsArray;\n}\n\n// The pure Selection Sort algorithm.\n// Selection sort is similar to bubble sort, but it guarantees that the first\n    // i elements are sorted rather than the last i. We find and move the minimum remaining\n    // element to the leftmost available spot on each iteration, but the only swap occurs\n    // at the end of each pass. O(n) swaps makes selection sort quite unique.\n//\n// The animations that are recorded are:\n// 1. An element is set as the current minimum.\n// 2. An element is compared to the current minimum.\n// 3. An element becomes the new current minimum.\n// 4. The current minimum is set to the rightmost sorted entry\n//    (at the end of each iteration).\nfunction selectionHelper(stateArray, animationsArray) {\n    for (let i=0; i<stateArray.length; i++) {\n        // Store the current minimum.\n        var current_min = i;\n        animationsArray.push([\"current_highlight\", i, i]);\n        for (let j=i+1; j<stateArray.length; j++) {\n            animationsArray.push([\"current_highlight\", j, j]);\n            // If a value is lower than the current minimum, it becomes the new minimum.\n            if (stateArray[current_min] > stateArray[j]) {\n                animationsArray.push([\"current_unhighlight\", current_min, current_min]);\n                current_min = j;\n                animationsArray.push([\"current_highlight\", j, j]);\n            }\n            // Otherwise, we ignore it.\n            else {\n                animationsArray.push([\"current_unhighlight\", j, j]);\n            }\n        }\n        // Move the current minimum to the leftmost available spot in the array.\n        animationsArray.push([\"current_unhighlight\", current_min, current_min]);\n        animationsArray.push([\"swap\", i, current_min]);\n        animationsArray.push([\"heights\", stateArray[i], stateArray[current_min]]);\n        const min_value = stateArray[current_min];\n        stateArray[current_min] = stateArray[i];\n        stateArray[i] = min_value;\n    }\n}","// Created by Zaddeen Benaissa, July 2020.\n\nimport React from 'react';\nimport SortingHome from './SortingHome/SortingHome';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div id=\"credits\">\n        <p id=\"self_tag\">Created by: Zaddeen Benaissa</p>\n        <a href=\"https://github.com/zaddeen/sorting_algorithms\" target=\"_blank\" rel=\"noopener noreferrer\">\n          <p id=\"website_link\"> https://github.com/zaddeen/sorting_algorithms </p>\n         </a>\n      </div>\n\n      <h1>Visualizing Sorting Algorithms</h1>\n      <SortingHome></SortingHome>\n    </div>\n  );\n}\n\nexport default App;\n ","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}